## API Report File for "@holoflows/kit"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import mitt from 'mitt';

// @public
export function AsyncCall<OtherSideImplementedFunctions = {}>(implementation: Record<string, (...args: any[]) => Promise<any>>, options?: Partial<AsyncCallOptions>): OtherSideImplementedFunctions;

// @public
export interface AsyncCallOptions {
    dontThrowOnNotImplemented: boolean;
    key: string;
    MessageCenter: {
        new (): {
            on(event: string, cb: (data: any) => void): void;
            send(event: string, data: any): void;
        };
    };
    serializer: Serialization;
    strictJSONRPC: boolean;
    writeToConsole: boolean;
}

// @public
export function AutomatedTabTask<T extends Record<string, (...args: any[]) => Promise<any>>>(taskImplements: T, options?: Partial<AutomatedTabTaskDefineTimeOptions>): ((url: string, options?: Partial<AutomatedTabTaskRuntimeOptions>) => T) | null;

// @public
export interface AutomatedTabTaskDefineTimeOptions extends AutomatedTabTaskSharedOptions {
    concurrent: number;
    key: string;
    memorizeTTL: number;
}

// @public
export interface AutomatedTabTaskRuntimeOptions extends AutomatedTabTaskSharedOptions {
    important: boolean;
    needRedirect: boolean;
    runAtTabID: number;
}

// @public
export interface AutomatedTabTaskSharedOptions {
    active: boolean;
    autoClose: boolean;
    memorable: boolean;
    pinned: boolean;
    timeout: number;
}

// @public
export type Contexts = 'background' | 'content' | 'webpage' | 'unknown' | 'options' | 'debugging';

// @public
export function DomProxy<ProxiedElement extends Node = HTMLElement, Before extends Element = HTMLSpanElement, After extends Element = HTMLSpanElement>(options?: Partial<DomProxyOptions<Before, After>>): DomProxy<ProxiedElement, Before, After>;

// @public
export interface DomProxy<ProxiedElement extends Node = HTMLElement, Before extends Element = HTMLSpanElement, After extends Element = HTMLSpanElement> {
    readonly after: After;
    readonly afterShadow: ShadowRoot;
    readonly before: Before;
    readonly beforeShadow: ShadowRoot;
    readonly current: ProxiedElement;
    destroy(): void;
    has(type: 'before'): Before | null;
    has(type: 'after'): After | null;
    has(type: 'beforeShadow' | 'afterShadow'): ShadowRoot | null;
    readonly observer: {
        readonly observer: MutationObserver | null;
        callback: MutationCallback | undefined;
        init: MutationObserverInit | undefined;
    };
    realCurrent: ProxiedElement | null;
}

// @public
export interface DomProxyOptions<Before extends Element = HTMLSpanElement, After extends Element = HTMLSpanElement> {
    afterShadowRootInit: ShadowRootInit;
    beforeShadowRootInit: ShadowRootInit;
    createAfter(): After;
    createBefore(): Before;
}

// @public
export class EventWatcher<T, Before extends Element = HTMLSpanElement, After extends Element = HTMLSpanElement, SingleMode extends boolean = false> extends Watcher<T, Before, After, SingleMode> {
    constructor(liveSelector: LiveSelector<T, SingleMode>);
    enableSingleMode: () => EventWatcher<T, Before, After, true>;
    eventListener: () => void;
}

// @public
export function GetContext(): Contexts;

// @public
export class IntervalWatcher<T, Before extends Element = HTMLSpanElement, After extends Element = HTMLSpanElement, SingleMode extends boolean = false> extends Watcher<T, Before, After, SingleMode> {
    enableSingleMode: () => IntervalWatcher<T, Before, After, true>;
    startWatch(interval: number): this;
    stopWatch(): void;
    }

// @public
export const JSONSerialization: (replacer?: ((this: any, key: string, value: any) => any) | undefined) => Serialization;

// @public
export class LiveSelector<T, SingleMode extends boolean = false> {
    clone(): LiveSelector<T, SingleMode>;
    closest<T>(parentOfNth: number): LiveSelector<T, SingleMode>;
    closest<K extends keyof HTMLElementTagNameMap>(selectors: K): LiveSelector<HTMLElementTagNameMap[K], SingleMode>;
    // (undocumented)
    closest<K extends keyof SVGElementTagNameMap>(selectors: K): LiveSelector<SVGElementTagNameMap[K], SingleMode>;
    // (undocumented)
    closest<E extends Element = Element>(selectors: string): LiveSelector<E, SingleMode>;
    concat<NextType>(newEle: LiveSelector<NextType, SingleMode>): LiveSelector<T | NextType, SingleMode>;
    enableSingleMode(): LiveSelector<T, true>;
    evaluateOnce(): SingleMode extends true ? (T | undefined) : T[];
    filter(f: (value: T, index: number, array: T[]) => any): LiveSelector<NonNullable<T>, SingleMode>;
    flat(): LiveSelector<T extends ArrayLike<infer U> ? U : never, SingleMode>;
    getElementsByClassName<T extends Element = Element>(className: string): LiveSelector<T, SingleMode>;
    getElementsByTagName<K extends keyof HTMLElementTagNameMap>(tag: K): LiveSelector<HTMLElementTagNameMap[K], SingleMode>;
    // (undocumented)
    getElementsByTagName<K extends keyof SVGElementTagNameMap>(tag: K): LiveSelector<SVGElementTagNameMap[K], SingleMode>;
    // (undocumented)
    getElementsByTagName<E extends Element = Element>(tag: string): LiveSelector<E, SingleMode>;
    map<NextType>(callbackfn: (element: T, index: number, array: T[]) => NextType): LiveSelector<NonNullable<NextType>, SingleMode>;
    nth(n: number): LiveSelector<T, SingleMode>;
    querySelector<K extends keyof HTMLElementTagNameMap>(selector: K): LiveSelector<HTMLElementTagNameMap[K], SingleMode>;
    // (undocumented)
    querySelector<K extends keyof SVGElementTagNameMap>(selector: K): LiveSelector<SVGElementTagNameMap[K], SingleMode>;
    // (undocumented)
    querySelector<E extends Element = Element>(selector: string): LiveSelector<E, SingleMode>;
    querySelectorAll<K extends keyof HTMLElementTagNameMap>(selector: K): LiveSelector<HTMLElementTagNameMap[K], SingleMode>;
    // (undocumented)
    querySelectorAll<K extends keyof SVGElementTagNameMap>(selector: K): LiveSelector<SVGElementTagNameMap[K], SingleMode>;
    // (undocumented)
    querySelectorAll<E extends Element = Element>(selector: string): LiveSelector<E, SingleMode>;
    replace<NextType>(f: (arr: T[]) => NextType[]): LiveSelector<NextType, SingleMode>;
    reverse(): LiveSelector<T, SingleMode>;
    slice(start?: number, end?: number): LiveSelector<T, SingleMode>;
    sort(compareFn?: (a: T, b: T) => number): LiveSelector<T, SingleMode>;
    // (undocumented)
    protected readonly stack: string | undefined;
}

// @public
export class MessageCenter<ITypedMessages> {
    constructor(instanceKey?: string);
    on<Key extends keyof ITypedMessages>(event: Key, handler: (data: ITypedMessages[Key]) => void): void;
    send<Key extends keyof ITypedMessages>(key: Key, data: ITypedMessages[Key], alsoSendToDocument?: boolean): void;
    // (undocumented)
    writeToConsole: boolean;
}

// @public
export class MutationObserverWatcher<T, Before extends Element = HTMLSpanElement, After extends Element = HTMLSpanElement, SingleMode extends boolean = false> extends Watcher<T, Before, After, SingleMode> {
    constructor(liveSelector: LiveSelector<T, SingleMode>, 
    consistentWatchRoot?: Node);
    enableSingleMode: () => MutationObserverWatcher<T, Before, After, true>;
    // (undocumented)
    protected liveSelector: LiveSelector<T, SingleMode>;
    // (undocumented)
    startWatch(options?: MutationObserverInit): this;
    // (undocumented)
    stopWatch(): void;
}

// @public
export const NoSerialization: Serialization;

// @public
export function OnlyRunInContext(context: Contexts | Contexts[], name: string): void;

// @public (undocumented)
export function OnlyRunInContext(context: Contexts | Contexts[], throws: false): boolean;

// @public
export interface Serialization {
    // (undocumented)
    deserialization(serialized: unknown): Promise<any>;
    // (undocumented)
    serialization(from: any): Promise<unknown>;
}

// @public
export class ValueRef<T> {
    constructor(_value: T);
    // Warning: (ae-forgotten-export) The symbol "Fn" needs to be exported by the entry point index.d.ts
    addListener(fn: Fn<T>): () => void;
    removeAllListener(): void;
    removeListener(fn: Fn<T>): void;
    value: T;
    }

// Warning: (ae-forgotten-export) The symbol "ResultOf" needs to be exported by the entry point index.d.ts
// 
// @public
export abstract class Watcher<T, Before extends Element, After extends Element, SingleMode extends boolean> implements PromiseLike<ResultOf<SingleMode, T>> {
    constructor(liveSelector: LiveSelector<T, SingleMode>);
    // Warning: (ae-forgotten-export) The symbol "EventCallback" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "OnIterationEvent" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    addListener(event: 'onIteration', fn: EventCallback<OnIterationEvent<T>>): this;
    // Warning: (ae-forgotten-export) The symbol "OnChangeEvent" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    addListener(event: 'onChange', fn: EventCallback<OnChangeEvent<T>>): this;
    // Warning: (ae-forgotten-export) The symbol "OnAddOrRemoveEvent" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    addListener(event: 'onRemove', fn: EventCallback<OnAddOrRemoveEvent<T>>): this;
    // (undocumented)
    addListener(event: 'onAdd', fn: EventCallback<OnAddOrRemoveEvent<T>>): this;
    assignKeys<Q = unknown>(keyAssigner: (node: T, index: number, arr: readonly T[]) => Q): this;
    // (undocumented)
    protected domProxyOption: Partial<DomProxyOptions<Before, After>>;
    // (undocumented)
    protected emit(event: 'onIteration', data: OnIterationEvent<T>): void;
    // (undocumented)
    protected emit(event: 'onChange', data: OnChangeEvent<T>): void;
    // (undocumented)
    protected emit(event: 'onRemove', data: OnAddOrRemoveEvent<T>): void;
    // (undocumented)
    protected emit(event: 'onAdd', data: OnAddOrRemoveEvent<T>): void;
    enableBatchMode(): this;
    abstract enableSingleMode(): Watcher<T, Before, After, true>;
    // (undocumented)
    protected _enableSingleMode(): this;
    protected readonly eventEmitter: mitt.Emitter;
    protected findNodeFromListByKey: (list: readonly T[], keys: readonly unknown[]) => (key: unknown) => T | null;
    readonly firstVirtualNode: T extends Node ? DomProxy<T, Before, After> : never;
    // (undocumented)
    protected _firstVirtualNode: DomProxy<any, Before, After>;
    getVirtualNodeByKey(key: unknown): DomProxy<any, Before, After> | null;
    protected isWatching: boolean;
    protected keyComparer: (a: unknown, b: unknown) => boolean;
    // Warning: (ae-forgotten-export) The symbol "useForeachReturns" needs to be exported by the entry point index.d.ts
    protected lastCallbackMap: Map<unknown, useForeachReturns<T>>;
    protected lastKeyList: readonly unknown[];
    protected lastNodeList: readonly T[];
    protected lastVirtualNodesMap: Map<unknown, DomProxy<any, Before, After>>;
    // (undocumented)
    protected liveSelector: LiveSelector<T, SingleMode>;
    protected mapNodeToKey: (node: T, index: number, arr: readonly T[]) => unknown;
    omitWarningForRepeatedKeys(): this;
    // (undocumented)
    removeListener(event: 'onIteration', fn: EventCallback<OnIterationEvent<T>>): this;
    // (undocumented)
    removeListener(event: 'onChange', fn: EventCallback<OnChangeEvent<T>>): this;
    // (undocumented)
    removeListener(event: 'onRemove', fn: EventCallback<OnAddOrRemoveEvent<T>>): this;
    // (undocumented)
    removeListener(event: 'onAdd', fn: EventCallback<OnAddOrRemoveEvent<T>>): this;
    // Warning: (ae-forgotten-export) The symbol "requestIdleCallback" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    protected readonly requestIdleCallback: typeof requestIdleCallback;
    // Warning: (ae-forgotten-export) The symbol "Deadline" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    protected scheduleWatcherCheck: (deadline?: Deadline | undefined) => void;
    setComparer<Q = unknown>(keyComparer?: (a: Q, b: Q) => boolean, valueComparer?: (a: T, b: T) => boolean): this;
    setDomProxyOption(option: Partial<DomProxyOptions<Before, After>>): this;
    // (undocumented)
    protected singleMode: boolean;
    protected singleModeCallback?: useForeachReturns<T>;
    protected singleModeHasLastValue: boolean;
    protected singleModeLastValue?: T;
    startWatch(...args: any[]): this;
    stopWatch(...args: any[]): void;
    then<TResult1 = ResultOf<SingleMode, T>, TResult2 = never>(onfulfilled?: ((value: ResultOf<SingleMode, T>) => TResult1 | PromiseLike<TResult1>) | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null, options?: {
        minimalResultsRequired?: number;
    }, starter?: (this: this, self: this) => void): Promise<TResult1 | TResult2>;
    useForeach(forEachFunction: useForeachFn<T, Before, After>): this;
    // Warning: (ae-forgotten-export) The symbol "useForeachFn" needs to be exported by the entry point index.d.ts
    protected useForeachFn?: useForeachFn<T, Before, After>;
    protected valueComparer: (a: T, b: T) => boolean;
    // (undocumented)
    protected _warning_forget_watch_: {
        warn(f?: (stack: string) => void): void;
        ignored: boolean;
        stack?: undefined;
    } | {
        ignored: boolean;
        stack: string;
        warn(f?: (stack: string) => void): void;
    };
    }


```
