## API Report File for "@holoflows/kit"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AsyncCallOptions } from 'async-call-rpc';
import { Emitter } from '@servie/events';

// @public
export function AutomatedTabTask<T extends Record<string, (...args: any[]) => PromiseLike<any>>>(taskImplements: T, options?: Partial<AutomatedTabTaskDefineTimeOptions>): ((urlOrTabID: string | number, options?: Partial<AutomatedTabTaskRuntimeOptions>) => T) | null;

// @public
export interface AutomatedTabTaskDefineTimeOptions extends AutomatedTabTaskSharedOptions {
    AsyncCallOptions: Partial<AsyncCallOptions>;
    concurrent: number;
    memorizeTTL: number;
}

// @public
export interface AutomatedTabTaskRuntimeOptions extends AutomatedTabTaskSharedOptions {
    important: boolean;
    needRedirect: boolean;
    runAtTabID: number;
    url: string;
}

// @public
export interface AutomatedTabTaskSharedOptions {
    active?: boolean;
    autoClose: boolean;
    memorable: boolean;
    pinned?: boolean;
    timeout: number;
}

// @public
export type Contexts = 'background' | 'content' | 'webpage' | 'unknown' | 'options' | 'debugging';

// @public
export function DOMProxy<ProxiedElement extends Node = HTMLElement, Before extends Element = HTMLSpanElement, After extends Element = HTMLSpanElement>(options?: Partial<DOMProxyOptions<Before, After>>): DOMProxy<ProxiedElement, Before, After>;

// @public (undocumented)
export namespace DOMProxy {
    var // (undocumented)
    enhanceDebugger: () => void;
}

// @public
export interface DOMProxy<ProxiedElement extends Node = HTMLElement, Before extends Element = HTMLSpanElement, After extends Element = HTMLSpanElement> extends Emitter<DOMProxyEvents<ProxiedElement>> {
    readonly after: After;
    readonly afterShadow: ShadowRoot;
    readonly before: Before;
    readonly beforeShadow: ShadowRoot;
    readonly current: ProxiedElement;
    destroy(): void;
    // (undocumented)
    readonly destroyed: boolean;
    has(type: 'before'): Before | null;
    has(type: 'after'): After | null;
    has(type: 'beforeShadow' | 'afterShadow'): ShadowRoot | null;
    readonly observer: {
        readonly observer: MutationObserver | null;
        callback: MutationCallback | undefined;
        init: MutationObserverInit | undefined;
    };
    realCurrent: ProxiedElement | null;
}

// @public
export interface DOMProxyEvents<ProxiedElement extends Node> {
    // @eventProperty
    currentChanged: [{
        new: ProxiedElement | null;
        old: ProxiedElement | null;
    }];
}

// @public
export interface DOMProxyOptions<Before extends Element = HTMLSpanElement, After extends Element = HTMLSpanElement> {
    afterShadowRootInit: ShadowRootInit;
    beforeShadowRootInit: ShadowRootInit;
    createAfter(): After;
    createBefore(): Before;
}

// @public
export class EventWatcher<T, Before extends Element = HTMLSpanElement, After extends Element = HTMLSpanElement, SingleMode extends boolean = false> extends Watcher<T, Before, After, SingleMode> {
    constructor(liveSelector: LiveSelector<T, SingleMode>);
    eventListener: () => void;
}

// @public
export function GetContext(): Contexts;

// @public
export class IntervalWatcher<T, Before extends Element = HTMLSpanElement, After extends Element = HTMLSpanElement, SingleMode extends boolean = false> extends Watcher<T, Before, After, SingleMode> {
    startWatch(interval: number): this;
    stopWatch(): void;
    }

// @public
export class LiveSelector<T, SingleMode extends boolean = false> {
    constructor(initialElements?: readonly T[]);
    clone(): LiveSelector<T, SingleMode>;
    closest<T>(parentOfNth: number): LiveSelector<T, SingleMode>;
    closest<K extends keyof HTMLElementTagNameMap>(selectors: K): LiveSelector<HTMLElementTagNameMap[K], SingleMode>;
    // (undocumented)
    closest<K extends keyof SVGElementTagNameMap>(selectors: K): LiveSelector<SVGElementTagNameMap[K], SingleMode>;
    // (undocumented)
    closest<E extends Element = Element>(selectors: string): LiveSelector<E, SingleMode>;
    concat<NextType>(newEle: LiveSelector<NextType, SingleMode>): LiveSelector<T | NextType, SingleMode>;
    enableSingleMode(): LiveSelector<T, true>;
    static enhanceDebugger(): void;
    evaluate(): SingleMode extends true ? T | undefined : T[];
    filter(f: (value: T, index: number, array: T[]) => any): LiveSelector<NonNullable<T>, SingleMode>;
    flat(): LiveSelector<T extends ArrayLike<infer U> ? U : never, SingleMode>;
    getElementsByClassName<T extends Element = Element>(className: string): LiveSelector<T, SingleMode>;
    getElementsByTagName<K extends keyof HTMLElementTagNameMap>(tag: K): LiveSelector<HTMLElementTagNameMap[K], SingleMode>;
    // (undocumented)
    getElementsByTagName<K extends keyof SVGElementTagNameMap>(tag: K): LiveSelector<SVGElementTagNameMap[K], SingleMode>;
    // (undocumented)
    getElementsByTagName<E extends Element = Element>(tag: string): LiveSelector<E, SingleMode>;
    isSingleMode: boolean;
    map<NextType>(callbackfn: (element: T, index: number, array: T[]) => NextType): LiveSelector<NonNullable<NextType>, SingleMode>;
    nth(n: SingleMode extends true ? 'LiveSelector.nth() is not available in SingleMode' : number): LiveSelector<T, SingleMode>;
    querySelector<K extends keyof HTMLElementTagNameMap>(selector: K): LiveSelector<HTMLElementTagNameMap[K], SingleMode>;
    // (undocumented)
    querySelector<K extends keyof SVGElementTagNameMap>(selector: K): LiveSelector<SVGElementTagNameMap[K], SingleMode>;
    // (undocumented)
    querySelector<E extends Element = Element>(selector: string): LiveSelector<E, SingleMode>;
    querySelectorAll<K extends keyof HTMLElementTagNameMap>(selector: K): LiveSelector<HTMLElementTagNameMap[K], SingleMode>;
    // (undocumented)
    querySelectorAll<K extends keyof SVGElementTagNameMap>(selector: K): LiveSelector<SVGElementTagNameMap[K], SingleMode>;
    // (undocumented)
    querySelectorAll<E extends Element = Element>(selector: string): LiveSelector<E, SingleMode>;
    replace<NextType>(f: (arr: T[]) => NextType[]): LiveSelector<NextType, SingleMode>;
    reverse(): LiveSelector<T, SingleMode>;
    slice(start?: number, end?: number): LiveSelector<T, SingleMode>;
    sort(compareFn?: (a: T, b: T) => number): LiveSelector<T, SingleMode>;
    }

// @public
export class MessageCenter<ITypedMessages> {
    constructor(sendToSelf: boolean, instanceKey?: string);
    emit<Key extends keyof ITypedMessages>(key: Key, data: ITypedMessages[Key]): Promise<void>;
    off<Key extends keyof ITypedMessages>(event: Key, handler: (data: ITypedMessages[Key]) => void): void;
    on<Key extends keyof ITypedMessages>(event: Key, handler: (data: ITypedMessages[Key]) => void): () => void;
    serialization: Serialization;
    writeToConsole(on: boolean): this;
}

// @public
export class MutationObserverWatcher<T, Before extends Element = HTMLSpanElement, After extends Element = HTMLSpanElement, SingleMode extends boolean = false> extends Watcher<T, Before, After, SingleMode> {
    constructor(
    liveSelector: LiveSelector<T, SingleMode>,
    consistentWatchRoot?: Node,
    stopWatchOnDisconnected?: boolean);
    // (undocumented)
    protected defaultStarterForThen(): void;
    protected liveSelector: LiveSelector<T, SingleMode>;
    startWatch(options: MutationObserverInit): this;
    stopWatch(): void;
    }

// @public
export function OnlyRunInContext(context: Contexts | Contexts[], name: string): void;

// @public
export function OnlyRunInContext(context: Contexts | Contexts[], throws: false): boolean;

// @public
export interface Serialization {
    deserialization(serialized: unknown): PromiseLike<any>;
    serialization(from: any): PromiseLike<unknown>;
}

// @public @eventProperty
export class ValueRef<T> {
    constructor(_value: T, isEqual?: (a: T, b: T) => boolean);
    addListener(fn: (newVal: T, oldVal: T) => void): () => void;
    // (undocumented)
    isEqual: (a: unknown, b: unknown) => boolean;
    removeAllListener(): void;
    removeListener(fn: (newVal: T, oldVal: T) => void): void;
    get value(): T;
    set value(newVal: T);
    }

// Warning: (ae-forgotten-export) The symbol "ResultOf" needs to be exported by the entry point index.d.ts
//
// @public
export abstract class Watcher<T, Before extends Element, After extends Element, SingleMode extends boolean> extends Emitter<WatcherEvents<T>> implements PromiseLike<ResultOf<SingleMode, T>> {
    constructor(liveSelector: LiveSelector<T, SingleMode>);
    assignKeys<Q = unknown>(keyAssigner: (node: T, index: number, arr: readonly T[]) => Q): this;
    // (undocumented)
    protected defaultStarterForThen(): void;
    dismissSingleModeWarning(): this;
    protected domProxyOption: Partial<DOMProxyOptions<Before, After>>;
    static enhanceDebugger(): void;
    protected findNodeFromListByKey: (list: readonly T[], keys: readonly unknown[]) => (key: unknown) => T | null;
    get firstDOMProxy(): T extends Node ? DOMProxy<T, Before, After> : never;
    protected _firstDOMProxy: DOMProxy<Node, Before, After>;
    getDOMProxyByKey(key: unknown): DOMProxy<any, Before, After> | null;
    protected isWatching: boolean;
    protected keyComparer: (a: unknown, b: unknown) => boolean;
    protected lastCallbackMap: Map<unknown, useForeachReturns<T>>;
    protected lastDOMProxyMap: Map<unknown, DOMProxy<any, Before, After>>;
    protected lastKeyList: readonly unknown[];
    protected lastNodeList: readonly T[];
    protected readonly liveSelector: LiveSelector<T, SingleMode>;
    protected mapNodeToKey: (node: T, index: number, arr: readonly T[]) => unknown;
    omitWarningForForgetWatch(): this;
    omitWarningForRepeatedKeys(): this;
    // Warning: (ae-forgotten-export) The symbol "requestIdleCallback" needs to be exported by the entry point index.d.ts
    protected readonly requestIdleCallback: typeof requestIdleCallback;
    protected scheduleWatcherCheck: () => void;
    setComparer(keyComparer?: (a: unknown, b: unknown) => boolean, valueComparer?: (a: T, b: T) => boolean): this;
    setDOMProxyOption(option: Partial<DOMProxyOptions<Before, After>>): this;
    protected get singleMode(): boolean;
    protected singleModeCallback?: useForeachReturns<T>;
    protected singleModeHasLastValue: boolean;
    protected singleModeLastValue?: T;
    startWatch(...args: any[]): this;
    stopWatch(...args: any[]): void;
    then<TResult1 = ResultOf<SingleMode, T>, TResult2 = never>(onfulfilled?: ((value: ResultOf<SingleMode, T>) => TResult1 | PromiseLike<TResult1>) | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null, options?: {
        minimalResultsRequired?: number;
        timeout?: number;
    }): Promise<TResult1 | TResult2>;
    // Warning: (ae-forgotten-export) The symbol "useForeachReturns" needs to be exported by the entry point index.d.ts
    useForeach(forEach: (element: T, key: unknown, metadata: T extends Node ? DOMProxy<T, Before, After> : unknown) => useForeachReturns<T>): this;
    protected useForeachFn?: Parameters<Watcher<T, any, any, any>['useForeach']>[0];
    protected valueComparer: (a: T, b: T) => boolean;
    protected _warning_forget_watch_: {
        warn(f?: (stack: string) => void): void;
        ignored: boolean;
        stack: string;
    };
    }

// @public (undocumented)
export interface WatcherEvents<T> {
    // @eventProperty (undocumented)
    onAdd: [{
        key: unknown;
        value: T;
    }];
    // @eventProperty (undocumented)
    onChange: [{
        oldKey: unknown;
        newKey: unknown;
        oldValue?: T;
        newValue: T;
    }];
    // @eventProperty (undocumented)
    onIteration: [{
        new: Map<unknown, T>;
        removed: Map<unknown, T>;
        current: Map<unknown, T>;
    }];
    // @eventProperty (undocumented)
    onRemove: [{
        key: unknown;
        value: T;
    }];
}


```
