## API Report File for "@holoflows/kit"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Emitter } from '@servie/events';
import type { EventListener as EventListener_2 } from '@servie/events';
import type { Runtime } from 'webextension-polyfill';

// @public
export function assertEnvironment(env: Environment): void;

// @public (undocumented)
export namespace assertEnvironment {
    var // (undocumented)
    oneOf: (...args: Environment[]) => void;
    var // (undocumented)
    allOf: (...args: Environment[]) => void[];
}

// @public
export function assertNotEnvironment(env: Environment): void;

// @public (undocumented)
export namespace assertNotEnvironment {
    var // (undocumented)
    oneOf: (...args: Environment[]) => void;
    var // (undocumented)
    allOf: (...args: Environment[]) => void[];
}

// @public
export function DOMProxy<ProxiedElement extends Node = HTMLElement, Before extends Element = HTMLSpanElement, After extends Element = HTMLSpanElement>(options?: Partial<DOMProxyOptions<Before, After>>): DOMProxy<ProxiedElement, Before, After>;

// @public
export interface DOMProxy<ProxiedElement extends Node = HTMLElement, Before extends Element = HTMLSpanElement, After extends Element = HTMLSpanElement> extends DOMProxy_Properties<ProxiedElement, Before, After> {
    // (undocumented)
    on(type: 'currentChanged', fn: (data: {
        new: ProxiedElement | null;
        old: ProxiedElement | null;
    }) => void): () => void;
}

// @public
export interface DOMProxy_MutationObserver {
    get callback(): MutationCallback | undefined;
    set callback(callback: MutationCallback | undefined);
    get init(): MutationObserverInit | undefined;
    set init(init: MutationObserverInit | undefined);
    readonly observer: MutationObserver | null;
}

// @public
export interface DOMProxy_Properties<ProxiedElement extends Node, Before extends Element, After extends Element> {
    readonly after: After;
    readonly afterShadow: ShadowRoot;
    readonly before: Before;
    readonly beforeShadow: ShadowRoot;
    readonly current: ProxiedElement;
    destroy(): void;
    // (undocumented)
    readonly destroyed: boolean;
    has(type: 'before'): Before | null;
    has(type: 'after'): After | null;
    has(type: 'beforeShadow' | 'afterShadow'): ShadowRoot | null;
    readonly observer: DOMProxy_MutationObserver;
    realCurrent: ProxiedElement | null;
}

// @public
export interface DOMProxyEvents<ProxiedElement extends Node> {
    // (undocumented)
    currentChanged: [{
        new: ProxiedElement | null;
        old: ProxiedElement | null;
    }];
}

// @public
export interface DOMProxyOptions<Before extends Element = HTMLSpanElement, After extends Element = HTMLSpanElement> {
    afterShadowRootInit: ShadowRootInit;
    beforeShadowRootInit: ShadowRootInit;
    createAfter(): After;
    createBefore(): Before;
}

// @public
export enum Environment {
    ContentScript = 8,
    ExtensionProtocol = 4,
    HasBrowserAPI = 2,
    ManifestAction = 256,
    ManifestBackground = 64,
    // @deprecated
    ManifestBrowserAction = 256,
    ManifestDevTools = 1024,
    ManifestOptions = 128,
    ManifestOverridesBookmarks = 8192,
    ManifestOverridesHistory = 16384,
    ManifestOverridesNewTab = 4096,
    // @deprecated
    ManifestPageAction = 512,
    ManifestSidebar = 2048,
    // (undocumented)
    NONE = 0
}

// @public
export class EventWatcher<T, Before extends Element = HTMLSpanElement, After extends Element = HTMLSpanElement, SingleMode extends boolean = false> extends Watcher<T, Before, After, SingleMode> {
    constructor(liveSelector: LiveSelector<T, SingleMode>);
    eventListener: () => void;
    // (undocumented)
    startWatch(signal?: AbortSignal): this;
}

// @public
export function getEnvironment(): Environment;

// @public
export class IntervalWatcher<T, Before extends Element = HTMLSpanElement, After extends Element = HTMLSpanElement, SingleMode extends boolean = false> extends Watcher<T, Before, After, SingleMode> {
    startWatch(interval: number, signal?: AbortSignal): this;
    stopWatch(): void;
}

// @public
export function isEnvironment(env: Environment): boolean;

// @public (undocumented)
export namespace isEnvironment {
    var // (undocumented)
    oneOf: (...args: Environment[]) => boolean;
    var // (undocumented)
    allOf: (...args: Environment[]) => boolean[];
}

// @public
export class LiveSelector<T, SingleMode extends boolean = false> {
    constructor(initialElements?: readonly T[]);
    at(n: SingleMode extends true ? 'LiveSelector.nth() is not available in SingleMode' : number): LiveSelector<T, SingleMode>;
    clone(): LiveSelector<T, SingleMode>;
    closest<T>(parentOfNth: number): LiveSelector<T, SingleMode>;
    closest<K extends keyof HTMLElementTagNameMap>(selectors: K): LiveSelector<HTMLElementTagNameMap[K], SingleMode>;
    // (undocumented)
    closest<K extends keyof SVGElementTagNameMap>(selectors: K): LiveSelector<SVGElementTagNameMap[K], SingleMode>;
    // (undocumented)
    closest<E extends Element = Element>(selectors: string): LiveSelector<E, SingleMode>;
    concat<NextType>(newEle: LiveSelector<NextType, SingleMode>): LiveSelector<T | NextType, SingleMode>;
    enableSingleMode(): LiveSelector<T, true>;
    evaluate(): SingleMode extends true ? T | undefined : T[];
    filter(f: (value: T, index: number, array: T[]) => any): LiveSelector<NonNullable<T>, SingleMode>;
    flat(): LiveSelector<T extends ArrayLike<infer U> ? U : never, SingleMode>;
    getElementsByClassName<T extends Element = Element>(className: string): LiveSelector<T, SingleMode>;
    getElementsByTagName<K extends keyof HTMLElementTagNameMap>(tag: K): LiveSelector<HTMLElementTagNameMap[K], SingleMode>;
    // (undocumented)
    getElementsByTagName<K extends keyof SVGElementTagNameMap>(tag: K): LiveSelector<SVGElementTagNameMap[K], SingleMode>;
    // (undocumented)
    getElementsByTagName<E extends Element = Element>(tag: string): LiveSelector<E, SingleMode>;
    isSingleMode: boolean;
    map<NextType>(callbackfn: (element: T, index: number, array: T[]) => NextType): LiveSelector<NonNullable<NextType>, SingleMode>;
    querySelector<K extends keyof HTMLElementTagNameMap>(selector: K): LiveSelector<HTMLElementTagNameMap[K], SingleMode>;
    // (undocumented)
    querySelector<K extends keyof SVGElementTagNameMap>(selector: K): LiveSelector<SVGElementTagNameMap[K], SingleMode>;
    // (undocumented)
    querySelector<E extends Element = Element>(selector: string): LiveSelector<E, SingleMode>;
    querySelectorAll<K extends keyof HTMLElementTagNameMap>(selector: K): LiveSelector<HTMLElementTagNameMap[K], SingleMode>;
    // (undocumented)
    querySelectorAll<K extends keyof SVGElementTagNameMap>(selector: K): LiveSelector<SVGElementTagNameMap[K], SingleMode>;
    // (undocumented)
    querySelectorAll<E extends Element = Element>(selector: string): LiveSelector<E, SingleMode>;
    replace<NextType>(f: (arr: T[]) => NextType[]): LiveSelector<NextType, SingleMode>;
    reverse(): LiveSelector<T, SingleMode>;
    slice(start?: number, end?: number): LiveSelector<T, SingleMode>;
    sort(compareFn?: (a: T, b: T) => number): LiveSelector<T, SingleMode>;
}

// @public (undocumented)
export enum MessageTarget {
    All = 2,
    Broadcast = 33554434,
    ExcludeLocal = 33554432,
    External = 16777216,
    FocusedPageOnly = 8388608,
    IncludeLocal = 1048576,
    LocalOnly = 2097152,
    VisiblePageOnly = 4194304
}

// @public
export class MutationObserverWatcher<T, Before extends Element = HTMLSpanElement, After extends Element = HTMLSpanElement, SingleMode extends boolean = false> extends Watcher<T, Before, After, SingleMode> {
    constructor(
    liveSelector: LiveSelector<T, SingleMode>,
    consistentWatchRoot?: Node,
    stopWatchOnDisconnected?: boolean);
    // (undocumented)
    protected defaultStarterForThen(): void;
    protected liveSelector: LiveSelector<T, SingleMode>;
    startWatch(options: MutationObserverInit, signal?: AbortSignal): this;
    stopWatch(): void;
}

// @public
export function printEnvironment(e?: Environment): string;

// @public
export interface Serialization {
    deserialization(serialized: unknown): unknown | PromiseLike<unknown>;
    serialization(from: any): unknown | PromiseLike<unknown>;
}

// @public (undocumented)
export type ShouldAcceptExternalConnection = (sender: Runtime.MessageSender) => ShouldAcceptExternalConnectionResult;

// @public (undocumented)
export type ShouldAcceptExternalConnectionResult = boolean | {
    acceptAs: Environment;
};

// @public (undocumented)
export interface TargetBoundEventListenerOptions {
    once?: boolean;
    signal?: AbortSignal;
}

// @public (undocumented)
export interface TargetBoundEventRegistry<T> {
    // (undocumented)
    off(callback: (data: T) => void): void;
    // (undocumented)
    on(callback: (data: T) => void, options?: TargetBoundEventListenerOptions): () => void;
    pause(): (reducer?: (data: T[]) => T[]) => Promise<void>;
    // (undocumented)
    send(data: T): void;
}

// @public (undocumented)
export interface UnboundedRegistry<T> extends Omit<TargetBoundEventRegistry<T>, 'send'>, AsyncIterable<T> {
    bind(target: MessageTarget | Environment, signal?: AbortSignal): TargetBoundEventRegistry<T>;
    // (undocumented)
    send(target: MessageTarget | Environment, data: T): void;
    // (undocumented)
    sendByBroadcast(data: T): void;
    // (undocumented)
    sendToAll(data: T): void;
    // (undocumented)
    sendToBackgroundPage(data: T): void;
    // (undocumented)
    sendToContentScripts(data: T): void;
    // (undocumented)
    sendToFocusedPage(data: T): void;
    // (undocumented)
    sendToLocal(data: T): void;
    // (undocumented)
    sendToVisiblePages(data: T): void;
}

// Warning: (ae-forgotten-export) The symbol "ResultOf" needs to be exported by the entry point index.d.ts
//
// @public
export abstract class Watcher<T, Before extends Element, After extends Element, SingleMode extends boolean> implements PromiseLike<ResultOf<SingleMode, T>> {
    constructor(liveSelector: LiveSelector<T, SingleMode>);
    // (undocumented)
    addListener<K extends keyof WatcherEvents<T>>(type: K, callback: EventListener_2<WatcherEvents<T>, K>, options?: AddEventListenerOptions): this;
    assignKeys<Q = unknown>(keyAssigner: (node: T, index: number, arr: readonly T[]) => Q): this;
    // (undocumented)
    protected defaultStarterForThen(): void;
    dismissSingleModeWarning(): this;
    protected domProxyOption: Partial<DOMProxyOptions<Before, After>>;
    protected findNodeFromListByKey: (list: readonly T[], keys: readonly unknown[]) => (key: unknown) => T | null;
    get firstDOMProxy(): T extends Node ? DOMProxy<T, Before, After> : never;
    protected _firstDOMProxy: DOMProxy<Node, Before, After>;
    getDOMProxyByKey(key: unknown): DOMProxy<any, Before, After> | null;
    protected isWatching: boolean;
    protected keyComparer: (a: unknown, b: unknown) => boolean;
    protected lastCallbackMap: Map<unknown, useForeachReturns<T>>;
    protected lastDOMProxyMap: Map<unknown, DOMProxy<any, Before, After>>;
    protected lastKeyList: readonly unknown[];
    protected lastNodeList: readonly T[];
    protected readonly liveSelector: LiveSelector<T, SingleMode>;
    protected mapNodeToKey: (node: T, index: number, arr: readonly T[]) => unknown;
    omitWarningForForgetWatch(): this;
    omitWarningForRepeatedKeys(): this;
    // (undocumented)
    removeListener<K extends keyof WatcherEvents<T>>(type: K, callback: EventListener_2<WatcherEvents<T>, K>): this;
    // Warning: (ae-forgotten-export) The symbol "requestIdleCallback_2" needs to be exported by the entry point index.d.ts
    protected readonly requestIdleCallback: typeof requestIdleCallback_2;
    protected scheduleWatcherCheck: () => void;
    setComparer(keyComparer?: (a: unknown, b: unknown) => boolean, valueComparer?: (a: T, b: T) => boolean): this;
    setDOMProxyOption(option: Partial<DOMProxyOptions<Before, After>>): this;
    protected get singleMode(): boolean;
    protected singleModeCallback?: useForeachReturns<T>;
    protected singleModeHasLastValue: boolean;
    protected singleModeLastValue?: T;
    startWatch(...args: any[]): this;
    stopWatch(...args: any[]): void;
    then<TResult1 = ResultOf<SingleMode, T>, TResult2 = never>(onfulfilled?: ((value: ResultOf<SingleMode, T>) => TResult1 | PromiseLike<TResult1>) | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null, options?: {
        minimalResultsRequired?: number;
        timeout?: number;
    }): Promise<TResult1 | TResult2>;
    // Warning: (ae-forgotten-export) The symbol "useForeachReturns" needs to be exported by the entry point index.d.ts
    useForeach(forEach: (element: T, key: unknown, metadata: T extends Node ? DOMProxy<T, Before, After> : unknown) => useForeachReturns<T>): this;
    protected useForeachFn?: Parameters<Watcher<T, any, any, any>['useForeach']>[0];
    protected valueComparer: (a: T, b: T) => boolean;
    protected _warning_forget_watch_: {
        warn(f?: (stack: string) => void): void;
        ignored: boolean;
        stack: string;
    };
}

// @public (undocumented)
export interface WatcherEvents<T> {
    // @eventProperty (undocumented)
    onAdd: [
        {
        key: unknown;
        value: T;
    }
    ];
    // @eventProperty (undocumented)
    onChange: [
        {
        oldKey: unknown;
        newKey: unknown;
        oldValue?: T;
        newValue: T;
    }
    ];
    // @eventProperty (undocumented)
    onIteration: [
        {
        new: Map<unknown, T>;
        removed: Map<unknown, T>;
        current: Map<unknown, T>;
    }
    ];
    // @eventProperty (undocumented)
    onRemove: [
        {
        key: unknown;
        value: T;
    }
    ];
}

// @public (undocumented)
export class WebExtensionMessage<Message> {
    constructor(options?: WebExtensionMessageOptions);
    static acceptExternalConnect(acceptExternalConnectFn: ShouldAcceptExternalConnection): void;
    get domain(): string;
    // (undocumented)
    enableLog: boolean;
    // (undocumented)
    protected get eventRegistry(): Emitter<Record<string, [unknown]>>;
    get events(): {
        readonly [K in keyof Message]: UnboundedRegistry<Message[K]>;
    };
    // (undocumented)
    log: (...args: unknown[]) => void;
    // (undocumented)
    logFormatter: (instance: this, key: string, data: unknown) => unknown[];
    serialization: Serialization;
}

// @public (undocumented)
export interface WebExtensionMessageOptions {
    readonly domain?: string;
    readonly externalExtensionID?: string;
}

```
