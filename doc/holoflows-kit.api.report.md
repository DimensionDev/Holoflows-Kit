## API Report File for "@holoflows/kit"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import mitt from 'mitt';

// @public
export function AsyncCall<OtherSideImplementedFunctions = {}>(implementation?: object, options?: Partial<AsyncCallOptions>): MakeAllFunctionsAsync<OtherSideImplementedFunctions>;

// @public
export interface AsyncCallOptions {
    key: string;
    log: {
        beCalled?: boolean;
        localError?: boolean;
        remoteError?: boolean;
        sendLocalStack?: boolean;
        type?: 'basic' | 'pretty';
    } | boolean;
    messageChannel: {
        on(event: string, callback: (data: unknown) => void): void;
        emit(event: string, data: unknown): void;
    };
    parameterStructures: 'by-position' | 'by-name';
    preferLocalImplementation: boolean;
    serializer: Serialization;
    strict: {
        methodNotFound?: boolean;
        noUndefined?: boolean;
        unknownMessage?: boolean;
    } | boolean;
}

// @public
export function AsyncGeneratorCall<OtherSideImplementedFunctions = {}>(implementation?: object, options?: Partial<AsyncCallOptions>): MakeAllGeneratorFunctionsAsync<OtherSideImplementedFunctions>;

// @public
export function AutomatedTabTask<T extends Record<string, (...args: any[]) => PromiseLike<any>>>(taskImplements: T, options?: Partial<AutomatedTabTaskDefineTimeOptions>): ((urlOrTabID: string | number, options?: Partial<AutomatedTabTaskRuntimeOptions>) => T) | null;

// @public
export interface AutomatedTabTaskDefineTimeOptions extends AutomatedTabTaskSharedOptions {
    AsyncCallOptions: Partial<AsyncCallOptions>;
    concurrent: number;
    memorizeTTL: number;
}

// @public
export interface AutomatedTabTaskRuntimeOptions extends AutomatedTabTaskSharedOptions {
    important: boolean;
    needRedirect: boolean;
    runAtTabID: number;
    url: string;
}

// @public
export interface AutomatedTabTaskSharedOptions {
    active: boolean;
    autoClose: boolean;
    memorable: boolean;
    pinned: boolean;
    timeout: number;
}

// @public
export type Contexts = 'background' | 'content' | 'webpage' | 'unknown' | 'options' | 'debugging';

// @public
export function DomProxy<ProxiedElement extends Node = HTMLElement, Before extends Element = HTMLSpanElement, After extends Element = HTMLSpanElement>(options?: Partial<DomProxyOptions<Before, After>>): DomProxy<ProxiedElement, Before, After>;

// @public
export interface DomProxy<ProxiedElement extends Node = HTMLElement, Before extends Element = HTMLSpanElement, After extends Element = HTMLSpanElement> {
    readonly after: After;
    readonly afterShadow: ShadowRoot;
    readonly before: Before;
    readonly beforeShadow: ShadowRoot;
    readonly current: ProxiedElement;
    destroy(): void;
    has(type: 'before'): Before | null;
    has(type: 'after'): After | null;
    has(type: 'beforeShadow' | 'afterShadow'): ShadowRoot | null;
    readonly observer: {
        readonly observer: MutationObserver | null;
        callback: MutationCallback | undefined;
        init: MutationObserverInit | undefined;
    };
    realCurrent: ProxiedElement | null;
}

// @public
export interface DomProxyOptions<Before extends Element = HTMLSpanElement, After extends Element = HTMLSpanElement> {
    afterShadowRootInit: ShadowRootInit;
    beforeShadowRootInit: ShadowRootInit;
    createAfter(): After;
    createBefore(): Before;
}

// @public
export class EventWatcher<T, Before extends Element = HTMLSpanElement, After extends Element = HTMLSpanElement, SingleMode extends boolean = false> extends Watcher<T, Before, After, SingleMode> {
    constructor(liveSelector: LiveSelector<T, SingleMode>);
    // @deprecated
    enableSingleMode: () => EventWatcher<T, Before, After, true>;
    eventListener: () => void;
}

// @public
export function GetContext(): Contexts;

// @public
export class IntervalWatcher<T, Before extends Element = HTMLSpanElement, After extends Element = HTMLSpanElement, SingleMode extends boolean = false> extends Watcher<T, Before, After, SingleMode> {
    // @deprecated
    enableSingleMode: () => IntervalWatcher<T, Before, After, true>;
    startWatch(interval: number): this;
    stopWatch(): void;
    }

// @public
export const JSONSerialization: ([replacer, receiver]?: [(string | number)[] | null | undefined, ((this: any, key: string, value: any) => any) | undefined], space?: string | number | undefined) => Serialization;

// @public
export class LiveSelector<T, SingleMode extends boolean = false> {
    constructor(initialElements?: readonly T[]);
    clone(): LiveSelector<T, SingleMode>;
    closest<T>(parentOfNth: number): LiveSelector<T, SingleMode>;
    closest<K extends keyof HTMLElementTagNameMap>(selectors: K): LiveSelector<HTMLElementTagNameMap[K], SingleMode>;
    // (undocumented)
    closest<K extends keyof SVGElementTagNameMap>(selectors: K): LiveSelector<SVGElementTagNameMap[K], SingleMode>;
    // (undocumented)
    closest<E extends Element = Element>(selectors: string): LiveSelector<E, SingleMode>;
    concat<NextType>(newEle: LiveSelector<NextType, SingleMode>): LiveSelector<T | NextType, SingleMode>;
    enableSingleMode(): LiveSelector<T, true>;
    evaluate(): SingleMode extends true ? (T | undefined) : T[];
    // @deprecated
    evaluateOnce(): SingleMode extends true ? (T | undefined) : T[];
    filter(f: (value: T, index: number, array: T[]) => any): LiveSelector<NonNullable<T>, SingleMode>;
    flat(): LiveSelector<T extends ArrayLike<infer U> ? U : never, SingleMode>;
    getElementsByClassName<T extends Element = Element>(className: string): LiveSelector<T, SingleMode>;
    getElementsByTagName<K extends keyof HTMLElementTagNameMap>(tag: K): LiveSelector<HTMLElementTagNameMap[K], SingleMode>;
    // (undocumented)
    getElementsByTagName<K extends keyof SVGElementTagNameMap>(tag: K): LiveSelector<SVGElementTagNameMap[K], SingleMode>;
    // (undocumented)
    getElementsByTagName<E extends Element = Element>(tag: string): LiveSelector<E, SingleMode>;
    map<NextType>(callbackfn: (element: T, index: number, array: T[]) => NextType): LiveSelector<NonNullable<NextType>, SingleMode>;
    nth(n: number): LiveSelector<T, SingleMode>;
    querySelector<K extends keyof HTMLElementTagNameMap>(selector: K): LiveSelector<HTMLElementTagNameMap[K], SingleMode>;
    // (undocumented)
    querySelector<K extends keyof SVGElementTagNameMap>(selector: K): LiveSelector<SVGElementTagNameMap[K], SingleMode>;
    // (undocumented)
    querySelector<E extends Element = Element>(selector: string): LiveSelector<E, SingleMode>;
    querySelectorAll<K extends keyof HTMLElementTagNameMap>(selector: K): LiveSelector<HTMLElementTagNameMap[K], SingleMode>;
    // (undocumented)
    querySelectorAll<K extends keyof SVGElementTagNameMap>(selector: K): LiveSelector<SVGElementTagNameMap[K], SingleMode>;
    // (undocumented)
    querySelectorAll<E extends Element = Element>(selector: string): LiveSelector<E, SingleMode>;
    replace<NextType>(f: (arr: T[]) => NextType[]): LiveSelector<NextType, SingleMode>;
    reverse(): LiveSelector<T, SingleMode>;
    slice(start?: number, end?: number): LiveSelector<T, SingleMode>;
    sort(compareFn?: (a: T, b: T) => number): LiveSelector<T, SingleMode>;
    }

// @public (undocumented)
export type MakeAllFunctionsAsync<T> = {
    [key in keyof T]: T[key] extends (...args: infer Args) => infer Return ? Return extends PromiseLike<infer U> ? (...args: Args) => Promise<U> : (...args: Args) => Promise<Return> : T[key];
};

// @public (undocumented)
export type MakeAllGeneratorFunctionsAsync<T> = {
    [key in keyof T]: T[key] extends (...args: infer Args) => Iterator<infer Yield, infer Return, infer Next> | AsyncIterator<infer Yield, infer Return, infer Next> ? (...args: Args) => AsyncIterator<UnboxPromise<Yield>, UnboxPromise<Return>, UnboxPromise<Next>> & {
        [Symbol.asyncIterator](): AsyncIterator<UnboxPromise<Yield>, UnboxPromise<Return>, UnboxPromise<Next>>;
    } : T[key];
};

// @public
export class MessageCenter<ITypedMessages> {
    constructor(instanceKey?: string);
    emit<Key extends keyof ITypedMessages>(key: Key, data: ITypedMessages[Key], alsoSendToDocument?: boolean): Promise<void>;
    off<Key extends keyof ITypedMessages>(event: Key, handler: (data: ITypedMessages[Key]) => void): void;
    on<Key extends keyof ITypedMessages>(event: Key, handler: (data: ITypedMessages[Key]) => void): () => void;
    send(...args: Parameters<MessageCenter<ITypedMessages>['emit']>): ReturnType<MessageCenter<ITypedMessages>['emit']>;
    serialization: import("../util").Serialization;
    writeToConsole: boolean;
}

// @public
export class MutationObserverWatcher<T, Before extends Element = HTMLSpanElement, After extends Element = HTMLSpanElement, SingleMode extends boolean = false> extends Watcher<T, Before, After, SingleMode> {
    constructor(
    liveSelector: LiveSelector<T, SingleMode>, 
    consistentWatchRoot?: Node);
    // @deprecated
    enableSingleMode: () => MutationObserverWatcher<T, Before, After, true>;
    protected liveSelector: LiveSelector<T, SingleMode>;
    startWatch(options?: MutationObserverInit): this;
    stopWatch(): void;
}

// @public
export const NoSerialization: Serialization;

// @public
export function OnlyRunInContext(context: Contexts | Contexts[], name: string): void;

// @public
export function OnlyRunInContext(context: Contexts | Contexts[], throws: false): boolean;

// @public
export interface Serialization {
    deserialization(serialized: unknown): PromiseLike<any>;
    serialization(from: any): PromiseLike<unknown>;
}

// @public (undocumented)
export type UnboxPromise<T> = T extends PromiseLike<infer U> ? U : T;

// @public
export class ValueRef<T> {
    constructor(_value: T);
    addListener(fn: (newVal: T, oldVal: T) => void): () => void;
    removeAllListener(): void;
    removeListener(fn: (newVal: T, oldVal: T) => void): void;
    value: T;
    }

// Warning: (ae-forgotten-export) The symbol "ResultOf" needs to be exported by the entry point index.d.ts
// 
// @public
export abstract class Watcher<T, Before extends Element, After extends Element, SingleMode extends boolean> implements PromiseLike<ResultOf<SingleMode, T>> {
    constructor(liveSelector: LiveSelector<T, SingleMode>);
    // Warning: (ae-forgotten-export) The symbol "EventCallback" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "OnIterationEvent" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    addListener(event: 'onIteration', fn: EventCallback<OnIterationEvent<T>>): this;
    // Warning: (ae-forgotten-export) The symbol "OnChangeEvent" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    addListener(event: 'onChange', fn: EventCallback<OnChangeEvent<T>>): this;
    // Warning: (ae-forgotten-export) The symbol "OnAddOrRemoveEvent" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    addListener(event: 'onRemove', fn: EventCallback<OnAddOrRemoveEvent<T>>): this;
    // (undocumented)
    addListener(event: 'onAdd', fn: EventCallback<OnAddOrRemoveEvent<T>>): this;
    assignKeys<Q = unknown>(keyAssigner: (node: T, index: number, arr: readonly T[]) => Q): this;
    dismissSingleModeWarning(): this;
    protected domProxyOption: Partial<DomProxyOptions<Before, After>>;
    // (undocumented)
    protected emit(event: 'onIteration', data: OnIterationEvent<T>): void;
    // (undocumented)
    protected emit(event: 'onChange', data: OnChangeEvent<T>): void;
    // (undocumented)
    protected emit(event: 'onRemove', data: OnAddOrRemoveEvent<T>): void;
    // (undocumented)
    protected emit(event: 'onAdd', data: OnAddOrRemoveEvent<T>): void;
    // @deprecated
    enableBatchMode(): this;
    // @deprecated
    abstract enableSingleMode(): Watcher<T, Before, After, true>;
    // (undocumented)
    protected _enableSingleMode(): this;
    protected readonly eventEmitter: mitt.Emitter;
    protected findNodeFromListByKey: (list: readonly T[], keys: readonly unknown[]) => (key: unknown) => T | null;
    readonly firstVirtualNode: T extends Node ? DomProxy<T, Before, After> : never;
    protected _firstVirtualNode: DomProxy<any, Before, After>;
    getVirtualNodeByKey(key: unknown): DomProxy<any, Before, After> | null;
    protected isWatching: boolean;
    protected keyComparer: (a: unknown, b: unknown) => boolean;
    protected lastCallbackMap: Map<unknown, useForeachReturns<T>>;
    protected lastKeyList: readonly unknown[];
    protected lastNodeList: readonly T[];
    protected lastVirtualNodesMap: Map<unknown, DomProxy<any, Before, After>>;
    protected readonly liveSelector: LiveSelector<T, SingleMode>;
    protected mapNodeToKey: (node: T, index: number, arr: readonly T[]) => unknown;
    omitWarningForForgetWatch(): this;
    omitWarningForRepeatedKeys(): this;
    // (undocumented)
    removeListener(event: 'onIteration', fn: EventCallback<OnIterationEvent<T>>): this;
    // (undocumented)
    removeListener(event: 'onChange', fn: EventCallback<OnChangeEvent<T>>): this;
    // (undocumented)
    removeListener(event: 'onRemove', fn: EventCallback<OnAddOrRemoveEvent<T>>): this;
    // (undocumented)
    removeListener(event: 'onAdd', fn: EventCallback<OnAddOrRemoveEvent<T>>): this;
    // Warning: (ae-forgotten-export) The symbol "requestIdleCallback" needs to be exported by the entry point index.d.ts
    protected readonly requestIdleCallback: typeof requestIdleCallback;
    protected scheduleWatcherCheck: () => void;
    setComparer<Q = unknown>(keyComparer?: (a: Q, b: Q) => boolean, valueComparer?: (a: T, b: T) => boolean): this;
    setDomProxyOption(option: Partial<DomProxyOptions<Before, After>>): this;
    protected readonly singleMode: boolean;
    protected singleModeCallback?: useForeachReturns<T>;
    protected singleModeHasLastValue: boolean;
    protected singleModeLastValue?: T;
    startWatch(...args: any[]): this;
    stopWatch(...args: any[]): void;
    then<TResult1 = ResultOf<SingleMode, T>, TResult2 = never>(onFulfilled?: ((value: ResultOf<SingleMode, T>) => TResult1 | PromiseLike<TResult1>) | null, onRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null, options?: {
        minimalResultsRequired?: number;
        timeout?: number;
    }, starter?: (this: this, self: this) => void): Promise<TResult1 | TResult2>;
    // Warning: (ae-forgotten-export) The symbol "useForeachReturns" needs to be exported by the entry point index.d.ts
    useForeach(forEach: (virtualNode: T, key: unknown, metadata: T extends Node ? DomProxy<T, Before, After> : unknown) => useForeachReturns<T>): this;
    protected useForeachFn?: Parameters<Watcher<T, any, any, any>['useForeach']>[0];
    protected valueComparer: (a: T, b: T) => boolean;
    protected _warning_forget_watch_: {
        warn(f?: (stack: string) => void): void;
        ignored: boolean;
        stack: string;
    };
    }


```
