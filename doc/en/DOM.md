# @holoflows/kit/DOM/

Help developer to track changes in the content script

Looking for [Documentation](#doc)?

## <a id="example">Example</a>

<details>
    <summary>Let's look an example.
    </summary>

Here we have a train ticket that generated by React.
It will automatically refresh, just like today's PWAs.

You want to add price in USD after every ticket.

```typescript
import { LiveSelector, MutationObserverWatcher } from '@holoflows/kit/DOM'

const price = new LiveSelector()
    // Select all .ticket-row
    .querySelector<HTMLDivElement>('.ticket-row')
    // Remove all that doesn't have Euro symbol
    .filter(x => x.innerText.match('€'))
    // map element to its inner .price
    .map(x => x.querySelector('.price'))

function EuroToUSD(x: number) {
    return x * 1.13
}

new MutationObserverWatcher(price, document.querySelector('#main')).useNodeForeach(node => {
    const addPrice = () => (node.after.innerText = '$' + EuroToUSD(parseInt(node.current.innerText)))
    addPrice()
    return {
        onNodeMutation: addPrice,
    }
})
```

Done! Everytime that a new ticket appears, price in US will be added after it.
But wait, it goes to far, I'm confused!

Okay, that's a just regular usage, shows how @holoflows/kit can help you.

After you read the intros, and back, you will understand these.

</details>

## <a id="example-liveselector">LiveSelector</a>

<details>
Everything starts at `LiveSelector`...

<summary>
LiveSelector is a convenient tool, to help you "compute" the same selector at any time. It looks like Array.
</summary>

```ts
const ls = new LiveSelector()
ls.querySelectorAll('a') // Select all `a`
ls.filter(x => x.href.startsWith('https://')) // Remove all link that not starts with https://
ls.map(x => x.href) // map HTMLAnchorElement[] to string[]

ls.evaluateOnce() // return all links on the page currently
setTimeout(() => {
    ls.evaluateOnce() // yeah it will match all links every time so you always get the latest data!
})
```

About the full documentation, see: [LiveSelector](#doc-LiveSelector)。

Then what is `MutationObserverWatcher`??

</details>

## <a id="example-watcher">Watcher</a>

<details>
Watcher can automatically execute `LiveSelector.evaluateOnce()`, then notify you when something has changed.
<summary>
In short words, it can watch the change of something.
</summary>
There are several kinds of Watcher:

-   MutationObserverWatcher (Using [MutationObserver](https://mdn.io/MutationObserver))
-   IntervalWatcher (Using [setInterval](https://mdn.io/setInterval))
-   EventWatcher (Call it manually)
-   ValueRef (Call it manually)

All Watcher's usage is the same:

-   To let it watch, call `startWatch()`
-   To stop it, call `stopWatch()`

In general, Watchers watch for changes of DOM. If you want to watch anything else, that's okay, Watcher provides some events like `onAdd` `onRemove`, See [Watcher](#doc-watchers)。

### <a id="example-watcher-usenodeforeach">`useNodeForeach`</a>

Here is how we watch dom changing. If you have used React hooks, this is just like React hooks.

A complete `useNodeForeach` call is like this:

```ts
.useNodeForeach((node, key, realNode) => {
    // Code here, will be called **everytime** when a new element E comes into the list. Here are parameters:
    node // A DomProxy (Yeah it's magic!)
    node.before // A <span> that always point to the before of E
    node.after // A <span> that always point to the after of E
    node.current // Magic, it always points to E, even E has changed, it "reference" will be "update" (Not actually, see documentation of DomProxy)

    key // Have you use React, Vue or Angular? When rendering lists, they will ask for you to provide a key to identify what is not changed.

    realNode // Sometimes the magic of node.current will break. Or you really want to access the real dom. Then use it. Notice: it will not update automatically!

    return {
        onRemove(old) {
            // When E is gone...
            // What you need to do?
            // Like React.useEffect(() => { return `function here` })
        },
        onNodeMutation() {
            // When key is not changed, E is not changed too.
            // But here is change in the E
            // Like a new element is inserted into node.current
        },
        onTargetChanged(oldNode, newNode) {
            // If key is not changed, but E is changed.
            // Notice: node.current always points to the new node, so you may not need to handle this
        },
    }
})
```

> Tips: If you only care about the first element in the `LiveSelector`, here is a shortcut! `Watcher#firstVirtualNode` is a `DomProxy` and it will always points to the first element in the list！

[Documentation of Watcher](#doc-watchers)

</details>
Tutorial is over.

# <a id="doc">Documentation</a>

## <a id="doc-liveselector">class LiveSelector</a>

All methods except `evaluateOnce()` can be chained.

```ts
const ls = new LiveSelector()
```

> Typescript: `LiveSelector` have a generic `<T>` to tell you the current type.

### <a id="doc-liveselector-queryselector">`.querySelector(selector)`</a>

Same as [document.querySelector](https://mdn.io/document.querySelector), add element to the list when evaluating.

```typescript
ls.querySelector('div#root').querySelector('.nav')
```

**Warn: Example above is union of `div#root` and `.nav`, is NOT `div#root .nav`**

> Typescript: Generic is the same as `document.querySelector`

> Typescript: For complex CSS selector, you need to specify it manually. Or you will get type `Element`. `.querySelector<HTMLDivElement>('div > div')`

### <a id="doc-liveselector-queryselectorall">`.querySelectorAll(selector)`</a>

Same as [document.querySelectorAll](https://mdn.io/document.querySelectorAll), add elements to the list when evaluating.

```typescript
ls.querySelectorAll('div').querySelectorAll('h1')
```

**Warn: Example above is union of `div` and `h1`, is NOT `div h1`**

> Typescript: Generic is the same as `document.querySelectorAll`

> Typescript: For complex CSS selector, you need to specify it manually. Or you will get type `Element`. `.querySelectorAll<HTMLDivElement>('div > div')`

### <a id="doc-liveselector-filter">`.filter(callbackfn)`</a>

Like [Array#filter](https://mdn.io/Array.filter). Remove items you don't want.

```ts
ls.filter(x => x.innerText.match('hello'))
```

### <a id="doc-liveselector-map">`.map(callbackfn)`</a>

Like [Array#map](https://mdn.io/Array.map). Map an item to another.

```ts
ls.map(x => x.parentElement)
```

**Tips: You can map to anything you want!**

### <a id="doc-liveselector-concat">`.concat(newLS: LiveSelector)`</a>

Like [Array#concat](https://mdn.io/Array.concat). Concat the result of another `LiveSelector.evaluateOnce()` into the current list.

```ts
ls.concat(new LiveSelector().querySelector('#root'))
```

### <a id="doc-liveselector-reverse">`.reverse()`</a>

Like [Array#reverse](https://mdn.io/Array.reverse). Reverse the list.

```ts
ls.reverse()
```

### <a id="doc-liveselector-slice">`.slice(start?, end?)`</a>

Like [Array#slice](https://mdn.io/Array.slice). Cut the list.

```ts
ls.slice(2, 4)
```

### <a id="doc-liveselector-sort">`.sort(compareFn)`</a>

Like [Array#sort](https://mdn.io/Array.sort). Sort the list.

```ts
ls.sort((a, b) => a.innerText.length - b.innerText.length)
```

### <a id="doc-liveselector-flat">`.flat()`</a>

Like [Array#flat](https://mdn.io/Array.flat). Flatten the list.

**Notice: Not recursively flating the list**

```ts
ls.flat()
```

### <a id="doc-liveselector-nth">`.nth(n: number)`</a>

Remove anything except nth element.

```ts
ls.nth(-1)
```

### <a id="doc-liveselector-replace">`.replace(f: (list: T[]) => NextT[])`</a>

If you think methods above is not enought, you can replace the list directly when evaluating.

```ts
ls.replace(x => lodash.dropRight(x, 2))
```

### <a id="doc-liveselector-evaluateonce">`.evaluateOnce()`</a>

Evaluate. This should be the last method to be called.

```ts
ls.evaluateOnce()
```

## <a id="doc-watchers">Watchers</a>

Every `Watcher` extends from abstract class [Watcher](#abstract-class-Watcher-public)。

### <a id="doc-watcher-public">abstract class Watcher (public)</a>

Extends [EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter)

#### <a id="doc-watcher-new">`constructor (liveSelector)`</a>

Create a new `Watcher`。

-   liveSelector: `LiveSelector<any>`, LiveSelector to watch

> Typescript: Generic `T` equals to generic of the `LiveSelector` passed in.

#### <a id="doc-watcher-startwatch">abstract `.startWatch(?): this`</a>

Start watching.

#### <a id="doc-watcher-stopwatch">abstract `.stopWatch()`</a>

Stop watching.

#### <a id="doc-watcher-addlistener">`.addListener(event, fn)`</a>

See [EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter).
Only these events are available.

-   onChange - When list updated, changed part
-   onChangeFull - When list updated, full list
-   onRemove - When list updated, removed part
-   onAdd - When list updated, added part

#### <a id="doc-watcher-firstvirtualnode">`.firstVirtualNode`</a>

**Notice: T must be sub type of HTMLElement, or it will be type `never`.**

A [DomProxy](#doc-domproxy), always points to the first result of `LiveSelector`.

#### <a id="doc-watcher-assignkeys">`.assignKeys(assigner, comparer?)`</a>

-   assigner: assign a key for each element. Key can be anything.
    Defaults to `x => x`

```ts
assigner: <Q = unknown>(node: T, index: number, arr: T[]) => Q
// node: node that needs a key
// index: current index
// arr: whole array
```

-   comparer: If your key can't be compared by `===`, provide a comparer.
    Defaults to `(a, b) => a === b`

```ts
comparer: (a: Q, b: Q) => boolean
// a: returned by assigner
// b: returned by assigner
```

#### <a id="doc-watcher-usenodeforeach">`.useNodeForEach(fn)`</a>

**Notice: T must be sub type of HTMLElement, or it will be type `never`.**

Everytime that a new item is added to the list, it will be called.

##### <a id="doc-watcher-usenodeforeach-fn">fn and it's return value</a>

```ts
(fn: (node: DomProxy, key: Q, realNode: HTMLElement) => ...)
// node: a DomProxy
// key: returned from assigner
// realNode: real node after DomProxy
```

-   undefined: nothing will happen
-   A function: `(oldNode: T) => void`, when `key` is gone, it will be called
-   An object: `{ onRemove?: (old: T) => void; onTargetChanged?: (oldNode: T, newNode: T) => void; onNodeMutation?: (node: T) => void }`
-   -   `onRemove(oldNode: T) => void`, when key is gone, it will be called
-   -   `onTargetChanged(oldNode: T, newNode: T) => void`, when `key` is still exist but `realNode` has changed, it will be called.
-   -   `onNodeMutation: (node: T) => void`, when `key` and `realCurrent` is not changed, but there are some mutations inside the `realCurrent`, it will be called.

#### <a id="doc-watcher-getvirtualnodebykey">`.getVirtualNodeByKey(key)`</a>

**Notice: T must be sub type of HTMLElement, or it will be type `never`.**

-   key: Q. Find [DomProxy](#doc-domproxy) by `key`

### <a id="doc-mutationobserverwatcher">MutationObserverWatcher</a>

#### <a id="doc-mutationobserverwatcher-new">`constructor (liveSelector, consistentWatchRoot = document.body)`</a>

Create a new `MutationObserverWatcher`。

It will listen on `consistentWatchRoot`. If any changes happened, it will do a check.

> At most 1 query every requestAnimateFrame. Don't worry

-   liveSelector: `LiveSelector<any>`, LiveSelector to watch
-   consistentWatchRoot: `Element | Document`, it should be consistent (if it is deleted, watcher will not work.). Defaults to `document.body`, if you think `MutationObserverWatcher` cause some performance problem, use this.

#### <a id="doc-mutationobserverwatcher-startwatch">`startWatch(options?: MutationObserverInit)`</a>

Start watching.

-   options: `MutationObserverInit`, you can remove some options by yourself. See: [MutationObserver](https://mdn.io/MutationObserver)

### <a id="doc-intervalwatcher">IntervalWatcher</a>

Check when time passed.

#### <a id="doc-intervalwatcher-startwatch">`.startWatch(interval)`</a>

Start watching.

-   options: `numebr`, check it at `options`ms

### <a id="doc-eventwatcher">EventWatcher</a>

Check when you want.

#### <a id="doc-eventwatcher-startwatch">`.startWatch()`</a>

Start watching.

#### <a id="doc-eventwatcher-eventlistener">`.eventListener()`</a>

Event listener.
Usage:

```ts
ele.addEventListener('click', watcher.eventListener)
```

### <a id="doc-valueref">ValueRef</a>

ValueRef is not related to `Watcher`. It listen to `.value =`. e.g.:

```ts
const ref = new ValueRef(0)
ref.value // 0
ref.addListener((newVal, old) => console.log(newVal, old))
ref.value = 1
// Log: 1, 0
ref.value // 1
```

#### <a id="doc-valueref-new">`constructor<T>(value: T)`</a>

-   value: Initial value

#### <a id="doc-valueref-value">`.value`</a>

Current value. If you assign it, then it will emit event.

#### <a id="doc-valueref-addlistener>`.addListener(fn: (newValue: T, oldValue: T) => void): () => void`</a>

Add a listener. If value get changed, it will be called with these parameters.

-   newValue: The new value
-   oldValue: The old value

`addListener` will return a function. Call that function will remove this listener. Be useful in React hooks.

```ts
const [val, setVal] = React.useState(0)
React.useEffect(() => ref.addListener(setVal))
```

#### <a id="doc-valueref-removelistener>`.removeListener(fn: (newValue: T, oldValue: T) => void): void`</a>

Remove listener.

#### <a id="doc-valueref-removealllistener>`.removeAllListener(): void`</a>

Remove all listeners.

### <a id="doc-watcher-protected">abstract class Watcher (protected)</a>

Here are `protected` fields and methods in the `Watcher` class. If you are not extending it, you don't need it.

#### <a id="doc-watcher-nodewatcher">protected readonly `.nodeWatcher: MutationWatcherHelper`</a>

Used to invoke `onNodeMutation`

`MutationWatcherHelper` is an un-exported internal class. Don't use it.

#### <a id="doc-watcher-watching">protected `.watching: boolean`</a>

Is it watching now?

If false, `.watcherCallback()` will do nothing.

#### <a id="doc-watcher-lastkeylist">protected `.lastKeyList: unknown[]`</a>

Key list of last time.

#### <a id="doc-watcher-lastnodelist">protected `.lastNodeList: T[]`</a>

Element list of last time.

#### <a id="doc-watcher-lastcallbackmap">protected `.lastCallbackMap: Map<unknown, useWatchCallback<T>>`</a>

All living return functions(like `onRemove` `onNodeMutation`)

#### <a id="doc-watcher-lastvirtualnodesmap">protected `.lastVirtualNodesMap: Map<unknown, DomProxy>`</a>

All living DomProxy

#### <a id="doc-watcher-findnodefromlistbykey">protected `.findNodeFromListByKey(list: T[], keys: unknown: []): (key: unknown) => T | null`</a>

A high order function. Find key in the list.

```ts
.findNodeFromListByKey(this.lastNodeList, this.lastKeyList)(key)
```

#### <a id="doc-watcher-watchercallback">protected `.watcherCallback()`</a>

Core of watcher. If you want to do a check, call it.

It does:

-   Call `LiveSelector.evaluateOnce()`
-   Call `assignKeys` to get `key`s

-   For deleted nodes, call `onRemove`
-   For new nodes, call `useNodeForeachFn()`
-   For changed nodes, call `onTargetChanged()`
-   Set `lastCallbackMap` `lastVirtualNodesMap` `lastKeyList` `lastNodeList`
-   Emit `onChangeFull` `onChange` `onRemove` `onAdd`
-   Bind `.firstVirtualNode.realCurrent` to new value.

#### <a id="doc-watcher-mapnodetokey">protected `.mapNodeToKey(node: T, index: number: arr: T[]): unknown`</a>

map node to key (can be overwrited by `assignKeys`)

#### <a id="doc-watcher-keycomparer">protected `.keyComparer(a: unknown, b: unknown): boolean`</a>

check if `a` and `b` are equal (can be overwrited by `assignKeys`)

#### <a id="doc-watcher-usenodeforeachfn">protected `.useNodeForeachFn(...): ...`</a>

See [.useNodeForeach](#doc-watcher-usenodeforeach-fn)

## <a id="doc-domproxy">DomProxy</a>

DomProxy provide an interface that be stable even dom is changed.

Return this object

### <a id="doc-domproxy-before">`.before`</a>

A span element, always at before of [realCurrent](#doc-domproxy-realCurrent)

### <a id="doc-domproxy-current">`.current`</a>

A fake HTML, all operations on it will be forwarded to [realCurrent](#doc-domproxy-realCurrent). After `realCurrent` changes, some of effects will be move to the new target.

### <a id="doc-domproxy-after">`.after`</a>

A span element, alwyas at after of [realCurrent](#doc-domproxy-realCurrent)

### <a id="dom-domproxy-realCurrent">`.realCurrent`</a>

The real current. If you change it, [after](#doc-domproxy-after), [current](#doc-domproxy-current), [before](#doc-domproxy-before) will be affected too.

### <a id="dom-domproxy-destroy">`.destroy()`</a>

Destroy the DomProxy.

### DOMProxy behavior

**Notice, only changes happened on current will be forwarded.**

-   forward: forward to the current`realCurrent`
-   undo: If `realCurrent` changed, effect will be undoed.
-   move: If `realCurrent` changed, effect will be moved.

| Attributes       | forward | undo | move |
| ---------------- | ------- | ---- | ---- |
| style            | Yes     | No   | Yes  |
| addEventListener | Yes     | Yes  | Yes  |
| appendChild      | Yes     | Yes  | Yes  |
| ...default       | Yes     | No   | No   |

This means, if you change `current.style.opacity`, then change `realCurrent`, new `realCurrent` will set `current.style.opacity` automatically.

**We will add more behavior later. If you need something, issues or pull requests wellcome!**
